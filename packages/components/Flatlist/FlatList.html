<svelte:window bind:scrollY="scrollY" />

{#if dataSection && dataSection.length > 0}
  <div class="flatlist {className}" style={_styles} ref:flatListRef>
    {#each dataSection.filter(Boolean) as section, sectionIndex (sectionIndex)}

      <!-- Handle title (if Section) -->
      {#if section.data}
        {#if section.title}
          {#if renderTitle}
            <svelte:component this="{renderTitle}" title={section.title}/>
            {:else}
              <div class="row row-title">
                <div class="title">{section.title}</div>
              </div>
          {/if}
        {/if}

        <!-- Render data itself -->
        {#each section.data.filter(Boolean) as item, index}
          {#if item.focusable}
            <FocusController data={item} on:create="register(this, index, sectionIndex, item)" />
          {:else}
            <Parent
              hasFirstFocusable={!!linkFirstFocusable}
              on:create="register(this, index, sectionIndex)"
              data={item}
              key={index}
              sectionIndex={sectionIndex}
              renderItem={renderItem}
              useAutoShortcuts={useAutoShortcuts}
              decorator={_setDecorator(decorator, item, decoratorOverrides)}
              on:_click="setSelected(event)"
            />
          {/if}
        {/each}

        <!-- Separator -->
        {#if showSeparator === true}
          {#if typeof _separator === 'object' && _separator.hasComponent && _separator.value}
            <svelte:component this="{_separator.value}"/>
          {:else}
            <div class="separator"></div>
          {/if}
        {/if}
      {/if}
    {/each}
  </div>

  <Keystroke key="enter" on:keystroke="selectRowItems(ENTER)"/>
  <Keystroke key="keyup" on:keystroke="selectRowItems(KEYUP)"/>
  <Keystroke key="keydown" on:keystroke="selectRowItems(KEYDOWN)"/>
{/if}

<script>
  import { ENTER, KEYUP, KEYDOWN } from '@mamba/pos/drivers/keyboard/keymap.js';
  import { selectRowItem, toggleActive, getStyles, shouldReturnComponent, scrollActiveNodeAtIndex } from './helpers.js';
  import isSomeInputElement from './utils/isSomeInputElement.js';
  import isFunction from './utils/isFunction.js';
  import { ACTIVE_MODEL } from './decorators.js';
  import { ARROW_CAPABILITIES_MODELS } from './const.js';

  const EVENTS = {
    ITEM_SELECTED: 'itemSelected',
    ITEM_ACTIVE: 'itemActive',
  };

  let _flatListElement;

  export default {
    components: {
      Parent: './components/parent.html',
      FocusController: './components/focusController.html',
      Keystroke: '@mamba/app/Keystroke.html',
    },
    helpers: {
      ENTER,
      KEYUP,
      KEYDOWN,
      _setDecorator(decorator, item, decoratorOverrides) {
        /**
         * @param decorator @type {func} @desc default decorator
         *
         * @param item @type {obj} @desc row from Flatlist data
         * @param decoratorOverrides @type {func} @desc custom decorator
         *
         * @summary if has custom decorator, sent it
         * */

        return isFunction(decorator) ?
          decorator(item, decoratorOverrides) : decorator;
      },
    },
    data() {
      return {
        intersectSelectedEvents: false,
        autoSelectOnTouch: true,
        autoShortcuts: false,
        renderItem: null,
        renderTitle: null,
        dataSection: undefined,
        data: undefined,
        separator: null,
        showSeparator: true,
        selectedIndex: 0,
        className: '',
        overrideEnterKeystroke: true,
        // eslint-disable-next-line max-len
        disableEnterKeystroke: false,
        disabled: false,
        linkFirstFocusable: undefined,
        _hasElement: false,
        _elementsRefs: [],
      };
    },
    computed: {
      _isKeystrokeActive({ _hasElement, disabled }) {
        if(disabled === true) return !disabled;
        if(_flatListElement && _hasElement) {
          return _flatListElement.offsetParent !== null;
        }
        return true;
      },
      _styles({ style }) {
        if(typeof style === 'string') return style;
        return getStyles(style);
      },
      /** @desc allow using shortcuts; do NOT work on dataSection */
      useAutoShortcuts({ dataSection, autoShortcuts }) {
        return autoShortcuts === true && dataSection && dataSection.length === 1;
      },
      _separator({ separator }) {
        return shouldReturnComponent(separator);
      },
    },
    oncreate() {
      this.fire('setup', { setupFirstFocusable: (elm, fr) => this.setupFirstFocusable(elm, fr) });
    },
    onupdate({changed, current}) {
      if(changed.data || changed.dataSection) {

        const { dataSection } = current;
        let { data } = current;

        const isDataArray = Array.isArray(data);
        const isSectionArray = Array.isArray(dataSection);

        if(!isDataArray && !isSectionArray) return;

        setTimeout(() => {
          const { flatListRef } = this.refs;
          _flatListElement = flatListRef;
          this.set({ _hasElement: typeof flatListRef !== 'undefined' });
        }, 10);
        /** */

        /** @desc handle arrow keys */
        const hasArrowCapabilities = ARROW_CAPABILITIES_MODELS.indexOf(ACTIVE_MODEL) === -1;

        this.set({
          _elementsRefs: [],
          disableEnterKeystroke: hasArrowCapabilities,
        });
        /** */

        /** @desc check if is section */
        const dataIsSection = (d) =>
          d.some(i => i.data && Array.isArray(i.data));
        /** */

        // filter dependencies from dataSection
        if (isSectionArray) {
          const sectionValid = this._validateDependencies(dataSection);

          this.set({
            dataSection: sectionValid,
          })
        }

        /** @desc check if is section && send data to component */
        if (isDataArray && data.length > 0) {
          const { linkFirstFocusable } = current;

          if(linkFirstFocusable) {
            data.unshift(linkFirstFocusable);
          }

          // filter dependencies from data
          const filteredData = this._validateDependencies(data);

          this.set({
            dataSection: [{
              title: null,
              data: filteredData,
            }],
          });
        }
      }
    },
    methods: {
      setSelected(parentProps, isKeystroke = false) {

        const {
          _elementsRefs,
          selectedIndex,
          autoSelectOnTouch,
          intersectSelectedEvents: intersect,
        } = this.get();

        let eventData = parentProps;

        if(!eventData) {
          if(!this.get()._isKeystrokeActive) return;
          const {
            sectionIndex,
            element,
            index,
            position,
          } = _elementsRefs[selectedIndex];

          eventData = {
            data: element.options.data.data,
            index,
            position,
            sectionIndex,
          };
        }

        const { data, position } = eventData;

        const internalIndex = position;

        const { element } = _elementsRefs[internalIndex - 1];

        eventData = {
          ...eventData,
          renderItemRefs: element.refs.renderItemRef.refs,
        };

        // needed because sometimes position is 0
        const filterPosition = Number(position) === 0 ? 9 : position - 1;

        this.set({ selectedIndex: filterPosition });

        if(autoSelectOnTouch && !(isKeystroke === true)) {
          toggleActive(_elementsRefs, internalIndex);
        }

        if(!intersect) this.fire(EVENTS.ITEM_SELECTED, eventData);

        if('onSelected' in data && typeof data.onSelected === 'function') {
          return data.onSelected(eventData);
        }

        if(intersect) this.fire(EVENTS.ITEM_SELECTED, eventData);
      },
      /** @desc register elements (allowing handle them) */
      register(element, index, sectionIndex, focusableItem = undefined) {
        const { _elementsRefs, selectedIndex, scrollY } = this.get();

        const position = _elementsRefs.length + 1;

        /** @desc prevent Flatlist show more than 10 shortcuts and show 10 as 0
         *  0 as string needed because 0 is false
        */
        const newPosition = position === 10 ? '0' : (position < 10 ? position : null);

        _elementsRefs.push({
          sectionIndex,
          element,
          index,
          position,
          focusableItem,
        });

        element.set({ position: newPosition });

        if(index === selectedIndex) {
          setTimeout(() => {
            scrollActiveNodeAtIndex(_elementsRefs, selectedIndex, scrollY);
          });
        }
      },
      selectRowItems(keyCode) {
        /**
         * KeyCode -> KeyName dictionary
         *
         *  38: 'keyup'
         *  40: 'keydown'
         *  13: 'enter'
         *
        */
        const {
          _isKeystrokeActive,
          disableEnterKeystroke,
        } = this.get();

        if(!_isKeystrokeActive) return;

        if(keyCode === ENTER && disableEnterKeystroke === false) {
          this.setSelected(undefined, true);
          return;
        }

        if(keyCode === KEYUP || keyCode === KEYDOWN) {
          const { scrollY, selectedIndex, _elementsRefs } = this.get();

          const internalIndex = selectRowItem(
            _elementsRefs,
            selectedIndex,
            scrollY,
            keyCode,
          );

          const target = _elementsRefs[internalIndex];

          this.selectRowAtTarget(target, internalIndex);
        }
      },
      selectRowAtTarget(targetItem, targetIndex) {
        const {
          sectionIndex,
          element,
          index,
          position,
        } = targetItem || {};

        const { data }  = element.options.data;

        this.fire(EVENTS.ITEM_ACTIVE, { index, sectionIndex, position, data });

        this.set({ selectedIndex: targetIndex });
      },
      setupFirstFocusable({
        element,
        forwardedRef,
      }) {
        if(!element) return false;

        try {
          const domElement = forwardedRef ? element.refs[forwardedRef] : element;
          const isComponent = !(domElement instanceof HTMLElement);

          if(isComponent || !isSomeInputElement(domElement)) return false;

          const self = {
            focusable: true,
            element,
            domElement,
            getBoundingClientRect () {
              let { getBoundingClientRect } = self.domElement;
              let thisArg = self.domElement;

              if(self.element.getBoundingClientRect) {
              // eslint-disable-next-line prefer-destructuring
                getBoundingClientRect = self.element.getBoundingClientRect;
                thisArg = self.element;
              }

              return getBoundingClientRect.call(thisArg);
            },
            focus() {
              self.domElement.focus();
            },
            blur() {
              self.domElement.blur();
            },
          };

          const _flatlist = this;
          domElement.onfocus = function _flatListFocus() {
            try {
              const { _elementsRefs, scrollY } = _flatlist.get();
              const target = _elementsRefs[0];
              scrollActiveNodeAtIndex(_elementsRefs, 0, scrollY);
              _flatlist.selectRowAtTarget(target, 0);
            } catch (_) {
              return null;
            }
          };

          if(__DEV__ ) {
            console.log('[FlatList] setupFirstFocusable', self);
          }

          // Register the first element user has focused row
          this.set({ linkFirstFocusable: self });

        } catch (error) {
          if(__DEV__ || __DEBUG_LVL__ >= 2) {
            console.log(error);
          }
          return false;
        }
      },
      _validateDependencies(list) {

        let filteredList = [];
        list.forEach(row => {

          const dataOrSection = [...(row.data || row)];

          const itemValidDependencies = dataOrSection.filter((data) => !data.dependencies || Object.values(data.dependencies).every(dep => dep === true));

          const newRow = row.data ? { ...row, data: itemValidDependencies } : itemValidDependencies;

          return filteredList = [...filteredList, ...newRow]
        });

        return filteredList;
      },
    },
  };
</script>

<style>
  .row {
    display: block;
    padding: 10px 20px;
    margin: 0;
    line-height: 1.5rem;
    background: #fff;
    border-bottom: 1px solid #f4f4f4;
    color: #494949;

    &-title {
      border-bottom: 1px solid $neutral100;
    }

    .title {
      color: $green500;
      font-size: 1.2rem;
    }
  }

  .separator {
    margin-bottom: 15px;
  }
</style>
